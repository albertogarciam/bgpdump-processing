#!/usr/bin/env python3

''' Utilities for processing as_path attributes as generated by the
bgpdump tool, e.g.:
"123 456 {789 12 34 56} 78 90"
An as_path is received as a string, containing only AS numbers
separated by spaces, { or }.
Note that 'AS345' is not a valid format.
The bgpdump representation of AS_SETs (see RFC4271), i.e.,  
AS numbers between brackets, e.g. {234 456}, is considered.

Prepending: same AS appearing consecutively in an as_path more than one.
E.g.: in '234 87 87 87 561', 87 is prepended.
Note that this is NOT prepending: '87 678 87'.
'''

# These utilities are defined in this file as functions. 
# For performance reasons, each function does not check if the input is 
# a valid as_path, as it assumes that it is checked (using is_as_path) before.
# 
# These utilities could have been defined as an object (e.g., As_path object). 
# The advantage would be that the as_path string could be validated when the
# object is created. 
# More performance gains could also be achieved in this case: as_path length 
# non-prepended representations could be computed when the object is created.
# The corresponding functions would just return the pre-computed values.
# This is useful only if there are many calls to these functions (not just one).


import re

def as_path_length(as_path: str)-> int:
    '''Counts as_path length, including prepended (repeated) occurrences. 
    AS_SETs count as 1 (see RFC4271, sect 9.1.2.2).'''

    as_count = 0

    # remove characters inside {}
    if '{' in as_path:
        as_path = re.sub("[{].*?[}]", "", as_path)
        # the whole AS_SET counts as 1
        as_count = 1

    as_path_list = as_path.strip()
    as_count = as_count + len(as_path_list.strip().split())

    return as_count


def count_ases(as_path: str) -> int:
    '''Counts ases in an as path, including prepended (repeated) occurrences.
    ASes inside AS_SETs are also counted - i.e., '{34 56 67}' counts as 3.'''

    return len(as_path.strip().split())


def as_path_length_no_prepending(as_path: str )-> int:
    '''Counts as path length after removing prepended occurrences.
    AS_SETs count as 1 (see RFC4271, sect 9.1.2.2).
    '''
    non_prepended = as_path_remove_prepending(as_path)

    return as_path_length(non_prepended)


def is_as_path(as_path: str) -> bool:
    '''Checks if a string is a valid as_path. 
    Must be numbers, spaces and { or }.
    For brackets, there can only be one group of brackets.
    An empty as_path is a valid one (the as_path for a 
    route originated at this AS).
    '''

    if not len(as_path):
        return True

    if '{' in as_path:
        # ensure there are only one {, }, and rest are digits or spaces
        if re.match("^[0-9 {}]+$", as_path) and (as_path.count('{') == 1) and (as_path.count('}') == 1):
            return True
        else:
            return False
    elif re.match("^[0-9 ]+$", as_path):
        return True
    else:
        return False


def as_path_remove_prepending(as_path: str ) -> str:
    '''Returns the as_path after removing prepended copies'''

    # empty as_path, return the empty string
    if not len(as_path):
        return ""

    aspath_list = as_path.strip().split()
    aspath_removed_list = [aspath_list[0],] 
    
    for i in range(len(aspath_list)-1):
        if aspath_list[i+1] != aspath_list[i]:
            aspath_removed_list.append(aspath_list[i+1])
    
    aspath_final_str=' '.join(aspath_removed_list)
    return aspath_final_str

    
def origin_as(as_path: str, accept_set: bool = False) -> str:
    '''Return the string representing the AS number 
    from which the route was originated (rightmost as).
    Generates an ValueError exception if the origin AS is an AS_SET (unless 
    accept_set is True).'''

    if as_path == "":
        return ""


    as_path_list = as_path.strip().split()
    last = as_path_list[-1]
    if not accept_set and '}' in last:
        raise ValueError

    return last

def neighbor_to_origin_as(as_path: str) -> str:
    '''Returns the string representing the AS number 
    of the first neighbor to the route origin.
    Returns "" if there is a single element
    Generates an exception if the closest AS is an AS_SET.'''

    if as_path == "":
        return ""

    as_path_list = as_path.strip().split()
    if len(as_path_list) <=1:
        return ""

    first = as_path_list[-2]
    if '{' in first:
        raise ValueError

    return first
    
def closest_as(as_path: str) -> str:
    '''Returns the string representing the AS number 
    from which the route was received (leftmost as).
    Generates an exception if the closest AS is an AS_SET.'''

    if as_path == "":
        return ""

    as_path_list = as_path.strip().split()
    first = as_path_list[0]
    if '{' in first:
        raise ValueError

    return first

def is_as_in_aspath(asn:str, as_path:str) -> bool:
    '''Returns True if the asn number appears in the as_path.
    It looks inside AS_PATH values.'''

    asn = asn.strip()
    as_path = as_path.strip()

    as_path = as_path.replace('{', ' ').replace('}', ' ')

    # easy check to see if an as_path is passed
    if ' ' in asn:
        raise ValueError

    # always check for surrounding spaces, to be sure the asn is complete
    return as_path.startswith(asn + ' ') or (' ' + asn + ' ' in as_path) or as_path.endswith(' ' + asn)


def maximum_common_path(as_path1: str, as_path2:str) -> str:
    '''Returns the string with the most common ASes, from route's origin,
    (rightmost ASes) for the two aspath provided.
    Does not remove prepending (if it exists). '''

    if (as_path1.strip() == "") or (as_path2.strip() == ""):
        return ""
    aspath_list1 = reversed(as_path1.strip().split())
    aspath_list2 = list(reversed(as_path2.strip().split()))

    common_aspath = []

    max_position2 = len(aspath_list2) -1

    for position, as1 in enumerate(aspath_list1):
        if position > max_position2:
            break

        if (aspath_list2[position]).strip() == as1.strip():
            common_aspath.append(as1.strip())
        else:
            break
    
    return (' '.join(reversed(common_aspath))).strip()